#!/usr/bin/env ruby
# Runs minitest tests using RSpec's test runner
#
# Examples:
#   Autoloads specs and tests:  https://github.com/JoshCheek/dotfiles/blob/7495046fbe4a927394558e7da43b07219b02594f/test/mrspec.feature#L9
#   fail fast:                  https://github.com/JoshCheek/dotfiles/blob/7495046fbe4a927394558e7da43b07219b02594f/test/mrspec.feature#L109
#   tagging:                    https://github.com/JoshCheek/dotfiles/blob/7495046fbe4a927394558e7da43b07219b02594f/test/mrspec.feature#L181
#
# Inspired by
#   https://github.com/rspec/rspec-core/issues/1786
#   https://gist.github.com/e2/bcd2be81b4ac28c85ea0

# presumably this is loose enough to not whine all the time, but tight enough to not break
gem 'rspec',    '~> 3.0'
gem 'minitest', '~> 5.0'

require 'rspec/core'
require 'minitest'

# Seems you have to give it as a CLI argument, otherwise it will overwrite your configuration when it processes CLI args
ARGV.unshift '--pattern', '{spec,test}/**/*_{spec,test}.rb'


RSpec.configure do |c|
  c.filter_gems_from_backtrace 'minitest'
  c.disable_monkey_patching!
end

class << Minitest::Runnable
  def metadata
    @metadata ||= Hash.new { |metadata, mname| metadata[mname] = {} }
  end

  private

  def method_added(manme)
    metadata[manme.intern].merge! pending_metadata
    pending_metadata.clear
  end

  def meta(metadata)
    pending_metadata.merge! metadata
  end

  def pending_metadata
    @pending_metadata ||= {}
  end
end


class MRspec
  def self.group_name(klass)
    klass.inspect.sub /Test$/, ''
  end

  def self.example_name(method_name)
    method_name.to_s.sub(/^test_/, '').tr('_', ' ')
  end

  def self.wrap_class(klass)
    example_group = RSpec.describe group_name(klass)
    klass.runnable_methods.each do |method_name|
      wrap_test example_group, klass, method_name
    end
  end

  def self.wrap_test(example_group, klass, mname)
    metadata = klass.metadata[mname.intern]
    example = example_group.example example_name(mname), metadata do
      instance = Minitest.run_one_method klass, mname
      instance.passed?  and next
      instance.skipped? and pending 'skipped'
      raise instance.failure
    end

    fix_metadata example.metadata, klass.instance_method(mname)
  end

  def self.fix_metadata(metadata, method)
    file, line = method.source_location
    return unless file && line
    metadata[:file_path]          = file
    metadata[:line_number]        = line
    metadata[:location]           = "#{file}:#{line}"
    metadata[:absolute_file_path] = File.expand_path(file)
  end

  class Runner < RSpec::Core::Runner
    def setup(*)
      super.tap { import_minitest }
    end

    def import_minitest
      # we're not using the reporter, but some plugins, (eg minitest/pride) expect it to be there
      Minitest.reporter = Minitest::CompositeReporter.new
      Minitest.load_plugins
      Minitest.init_plugins Minitest.process_args([])

      Minitest::Runnable.runnables.each do |klass|
        MRspec.wrap_class(klass)
      end
    end
  end
end

MRspec::Runner.autorun
