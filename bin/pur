#!/usr/bin/env ruby

class Pur
  def self.help_screen
    <<-HELP_SCREEN.gsub /^    /, ''
    Usage: pur [HorizontalMap | HorizontalFilter | Regexp]* (- VerticalInitialValue VerticalReduction VerticalMap?)?

      Used to map/filter/reduce stdin with familiar Rubyisms

      Heavily inspired by pru (https://rubygems.org/gems/pru)

      HorizontalMap:
        Is used to map the current line to a new value.
        Any expression that evaluates to a non true/false/nil value is considered a map
        Each map is evaluated within the context of the result of the previous map, with the initial value being the current line.

        e.g. Map lines to line length

             $ ruby -e 'puts "aaa\\nbb"' | pur size
             3
             2

      HorizontalFilter:
        Any expression which returns true/false/nil is used to filter the results.
        The current expression will be kept if the result is true, and discarded if it is false/nil.

        e.g. Find lines with three characters

             $ ruby -e 'puts "aaa\\nbb"' | pur 'size == 3'
             aaa

      Regexp:
        Any regexp is used to filter the results, it is equivalent to 'regexp === to_s'

      VerticalInitialValue:
        When performing a vertical reduction (pass the mapped/filtered results to a function which aggregates them and prints at the end)
        This provides the initial value.

      VerticalReduction:
        This code will be passed each mapped/filtered result, it can access the aggregate value through _,
        it will be printed at the end of the input

        e.g. Sum numbers

             $ ruby -e 'puts *1..10' | pur to_i - 0 '_ + self'
             55

        e.g. Join lines

             $ ruby -e 'puts *"a".."c"' | pur - String.new '_ << self'
             abc

      VerticalMap:
        If the aggregate value isn't what you want to print, you can map it to a new value here

        e.g. Makes output unique

             $ ruby -e 'puts *%w[c b a c a b c]' | pur - Hash.new '_[self]=true; _' keys.sort.join
             abc

        e.g. Prints line frequencies

             $ ruby -e 'puts *%w[c a c a b c]' | pur - 'Hash.new 0' '_[self]+=1; _' 'sort_by { |_,count| -count }.map { |line, count| "\#{count} \#{line}" }'
             3 c
             2 a
             1 b

    HELP_SCREEN
  end

  def initialize(argv, instream, outstream, errstream)
    self.argv         = convert_regexes argv
    self.instream     = instream
    self.outstream    = outstream
    self.errstream    = errstream
    @should_show_help = argv.any? { |arg| arg == '-h' || arg == '--help' }
    set_vertical_reduction_vars argv
  end

  def call
    show_help || error_on_bad_args || map_and_reduce_lines || print_reduction
  rescue Exception
    errstream.puts $!.message
    return 1
  end

  private

  def show_help
    return unless show_help?
    outstream.puts self.class.help_screen
    0
  end

  def error_on_bad_args
    raise @error_message if @error_message
  end

  def map_and_reduce_lines
    instream.each_line do |line|
      result = reduce_across line.chomp
      next unless result
      reduce_down? ? vertical_reduction(result) : outstream.puts(result)
    end
    0 unless reduce_down?
  end

  def print_reduction
    outstream.puts @vertical_value.instance_eval @post_reduction_map
    0
  end

  def show_help?
    @should_show_help
  end

  def set_vertical_reduction_vars(argv)
    @should_reduce_down = argv.include? '-'
    return unless reduce_down?
    size = argv[argv.index('-')..-1].size
    case size
    when 3, 4
      argv = argv + ['self'] if size == 3
      @vertical_value, @vertical_reducer, @post_reduction_map = argv[-3..-1]
      @vertical_value = eval @vertical_value
    when 0, 1
      @error_message = "Must provide an initial value to the vertical reduction#{argv.inspect}"
    else
      @error_message = "Expecting an initial value, code to run, and post-reduction mapping (two or three arguments to the right of the dash)"
    end
  end


  def vertical_reduction(current_line)
    @vertical_value = current_line.instance_eval("-> _ { #@vertical_reducer }").call(@vertical_value)
  end

  def reduce_down?
    @should_reduce_down
  end

  def convert_regexes(args)
    args.map do |arg|
      if arg.start_with? "/" then "#{arg} === to_s" else arg end
    end
  end

  def reduce_across(line)
    old_var = var = line
    argv.each do |arg|
      return var if arg == '-'
      var = apply arg, var
      return unless var
      return old_var if var == true
      old_var = var
    end
    var
  end

  def apply(applier, applyee)
    applyee.instance_eval applier
  end

  attr_accessor :argv, :instream, :outstream, :errstream
end

if $0 !~ /rspec/
  exit Pur.new(ARGV, $stdin, $stdout, $stderr).call
else
  describe Pur do
    require 'stringio'

    Invocation = Struct.new :exitstatus, :out_string, :err_string

    def invoke(input_lines, argv)
      stdin  = StringIO.new input_lines.join("\n")
      stdout = StringIO.new
      stderr = StringIO.new
      Invocation.new described_class.new(argv, stdin, stdout, stderr).call,
                     stdout.string,
                     stderr.string
    end

    it 'treats regexes as selections' do
      invoke(%w[abc def cAb], ['/a/']).out_string.should == "abc\n"
      invoke(%w[abc def cAb], ['/a/i']).out_string.should == "abc\ncAb\n"
    end

    it 'treats boolean expressions as selections' do
      invoke(%w[abc def cAb], ['start_with? "d"']).out_string.should == "def\n"
    end

    it 'treats other expressions as mappings' do
      invoke(%w[abc defg], ['size']).out_string.should == "3\n4\n"
    end

    it 'allows these to be chained together, with self as the result of the previous mapping' do
      invoke(%w[abc defg], %w[chars to_a last ord]).out_string.should == "99\n103\n"
    end

    it 'converts mapped things to strings for successant regexes to match against' do
      invoke(%w[aaa bb cccc], %w[size /3|4/]).out_string.should == "3\n4\n"
    end

    it 'allows a reduction after a dash, with _ being bound to the previous result, and self the current result' do
      invoke(%w[abc defg], %w[- 0 _+size]).out_string.should == "7\n"
      invoke(%w[abc defg hijkl], %w[/a|d/ size - 10 _+size]).out_string.should == "17\n"
    end

    it 'raises an error if not given a starting value' do
      invoke(%w[abc defg], %w[-]).out_string.should == ""
      invoke(%w[abc defg], %w[-]).err_string.should include "initial value"
      invoke(%w[abc defg], %w[-]).exitstatus.should_not be_zero

      invoke(%w[abc defg], %w[- _+size]).out_string.should == ""
      invoke(%w[abc defg], %w[- _+size]).err_string.should include "initial value"
      invoke(%w[abc defg], %w[- _+size]).exitstatus.should_not be_zero
      invoke(%w[abc defg], %w[- 10 _+size]).exitstatus.should == 0
    end

    it 'treats more than three arguments as an error' do
      invoke(%w[abc defg], %w[- 0 1 2 3 4]).err_string.should include "three arguments"
    end

    it 'treats an optional third parameter as a mapping before printing (that way you can aggregate in one structure, but print in another)' do
      invoke(%w[a b a c a], ['-', '{}', '_[self]=true;_', 'keys.sort.join']).out_string.should == "abc\n"
    end

    it 'reports errors to stderr, and exits with a non-zero exit status' do
      invoke(%w[abc], ['self']).out_string.should == "abc\n"
      invoke(%w[abc], ['self']).err_string.should == ""
      invoke(%w[abc], ['self']).exitstatus.should be_zero

      invoke(%w[abc], ['raise("omg")']).out_string.should == ""
      invoke(%w[abc], ['raise("omg")']).err_string.should == "omg\n"
      invoke(%w[abc], ['raise("omg")']).exitstatus.should_not be_zero
    end

    it 'reports usage when given the -h or --help flags' do
      invoke(%w[abc], ['-h']).out_string.should == Pur.help_screen
      invoke(%w[abc], ['-h']).err_string.should == ''
      invoke(%w[abc], ['-h']).exitstatus.should == 0

      invoke(%w[abc], ['--help']).out_string.should == Pur.help_screen
      invoke(%w[abc], ['--help']).err_string.should == ''
      invoke(%w[abc], ['--help']).exitstatus.should == 0
    end
  end
end
