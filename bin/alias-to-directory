#!/usr/bin/env ruby

class AliasToDirectory
  Definition = Struct.new :alias, :directory

  def initialize(raw_definitions, argv)
    @raw_definitions, @argv = raw_definitions, argv
  end

  def self.help_text
    "HELP SCREEN"
  end

  # returns primary_output_string   (e.g. print it to stdout)
  #         info_output_string      (e.g. print it to stderr)
  #         whether_program_errored (e.g. false implies exit status 0)
  def call
    @result ||= begin
      definitions = parse_defs @raw_definitions
      flags, args = parse_args @argv
      output      = ''
      info_output = ''
      had_error   = false

      if flags.include?('-h') || flags.include?('--help')
        return self.class.help_text, "", false
      end

      aliases_with_no_directories = definitions.reject(&:directory)
      if aliases_with_no_directories.any?
        info_output << "The following aliases are missing directories:\n"
        aliases_with_no_directories.each do |definition|
          info_output << "  #{definition.alias}\n"
        end
        had_error = true
      end

      conflicting_definitions =
        definitions.group_by(&:alias)
                   .reject { |a, ds| ds.map(&:directory).uniq.size == 1 }
      if conflicting_definitions.any?
        info_output << "Multiple aliases with conflicting directories:\n"
        conflicting_definitions.each do |a, definitions|
          info_output << "  #{a}\n"
          definitions.each { |d| info_output << "    #{d.directory}\n" }
        end
        had_error = true
      end

      if definitions.empty?
        info_output << "You must provide a list of directories to match on stdin"
        had_error = true
      end

      unless had_error
        definition = definitions.find do |definition|
          provided_alias = args.first
          definition.alias == provided_alias
        end
        output << definition.directory
      end
      [output, info_output, had_error]
    end
  end

  private

  def parse_args(argv)
    argv.each_with_object([[], []]) do |arg, (flags, args)|
      (arg.start_with?('-') ? flags : args) << arg
    end
  end

  def parse_defs(raw_definitions)
    raw_definitions.lines.map do |raw_definition|
      Definition.new *raw_definition.strip.split(/\s+/, 2)
    end
  end
end



if $0 !~ /rspec/
  # tap so that local vars up here don't override let blocks down below
  AliasToDirectory.new($stdin.read, ARGV).call.tap do |output, info_output, had_error|
    $stdout.print output
    $stderr.print info_output
    exit had_error
  end
else
  RSpec.configure &:disable_monkey_patching!

  module ::RSpec::Core::MemoizedHelpers::ClassMethods
    def lets(*names, &block)
      results = {}
      set_results = lambda do
        block.call.zip(names).each { |value, name| results[name] = value }
        results
      end

      names.each do |name|
        let(name) { results.fetch(name) { set_results.call[name] } }
      end
    end
  end

  RSpec.describe 'alias-to-directory' do
    def call(aliases, argv)
      AliasToDirectory.new(aliases, argv).call
    end

    def expect_result(aliases, argv, expected)
      output, info_output, had_error = call(aliases, argv)
      expect(info_output).to be_empty
      expect(had_error   ).to be_falsy
      expect(output      ).to eq expected
    end

    def expect_info_matches(aliases, argv, *expected_patterns)
      _, info_output, _ = call(aliases, argv)
      expected_patterns.each do |expected_pattern|
        expect(info_output).to match expected_pattern
      end
    end

    def expect_error(aliases, argv)
      *, had_error = call(aliases, argv)
      expect(had_error).to be_truthy
    end

    context 'reading alias list' do
      it 'reads the list as "alias1 dir1\n alias2 dir2\n ..."' do
        aliases = "alias1 dir1\n alias2 dir2"
        expect_result aliases, ['alias1'], 'dir1'
        expect_result aliases, ['alias2'], 'dir2'
      end

      it 'doesn\'t care about trailing newline in the alias list' do
        expect_result "alias dir",   ['alias'], 'dir'
        expect_result "alias dir\n", ['alias'], 'dir'
      end

      it "doesn't care about leading/trailing whitespace" do
        expect_result " \t    alias dir    \t  ",   ['alias'], 'dir'
      end

      it "doesn't care about whitespace between the alias and dir" do
        expect_result "alias  \t    dir",   ['alias'], 'dir'
      end

      it "treats all whitespace after the first one as being part of the path" do
        expect_result "alias d i r",   ['alias'], 'd i r'
      end
    end

    context 'when the alias definition list is empty' do
      lets(:output, :info_output, :had_error) { AliasToDirectory.new("", ["a"]).call }
      it('has nothing in the output string') { expect(output).to be_empty }
      it('says so in the info string')       { expect(info_output).to include "must provide a list" } # kinda fragile
      it('has an error')                     { expect(had_error).to be_truthy }
    end

    context 'when alias has no directory' do
      let(:alias_name) { 'alias-with-no-dir' }

      it 'says so and errors' do
        expect_info_matches alias_name, [alias_name], /missing director/i
        expect_info_matches alias_name, [alias_name], /#{alias_name}/
        expect_error alias_name, [alias_name]
      end
    end

    context 'when there is an alias match' do
      lets(:output, :info_output, :had_error) { AliasToDirectory.new("a d", ['a']).call }
      it('outputs the directory')  { expect(output      ).to eq "d" }
      it('it has no error output') { expect(info_output).to be_empty }
      it('exits with 0')           { expect(had_error   ).to be_falsy }
    end


    context 'when same alias multiple times' do
      context 'with same directory' do
        lets(:output, :info_output, :had_error) { AliasToDirectory.new("a d\na d", ['a']).call }
        it('outputs the match only once') { expect(output).to eq "d" }
        it('does not have error output') { expect(info_output).to be_empty }
        it('has no error')               { expect(had_error).to equal false }
      end

      context 'with different directories' do
        let(:alias_defs) { "a d1\n a d2" }
        it('has an error') { expect_error alias_defs, ['a'] }
        it 'says so in error output' do
          expect_info_matches alias_defs, ['a'], /conflicting director/i, /\ba\b/, /\bd1\b/, /\bd2\b/
        end
      end
    end

    context 'when a search alias is not provided' do
      it 'includes help in info string'
      it 'exits with 1 if not given args'
    end

    context 'when there is a partial alias match' do
      it 'shows possible matches in info string'
      it 'exits with 1'
    end

    context 'when there is more than one argument provided' do
      it 'has the error message in the info string'
      it 'exits with 1'
    end

    context '--help, -h' do
      let(:directory_name) { 'DIRECTORY_NAME' }

      def for_each
        ['-h', '--help'].each do |flag|
          yield call('', [flag])
          yield call('a', [flag])
          yield call("a #{directory_name}", ['a', flag])
        end
      end

      it 'outputs help' do
        for_each { |output, *| expect(output).to eq AliasToDirectory.help_text }
      end

      it 'does not output a directory match' do
        for_each { |output, *| expect(output).to_not include directory_name }
      end

      it 'has no error output, even if it would otherwise exist' do
        for_each { |_, info_output| expect(info_output).to be_empty }
      end

      it 'has no errors, even if they would otherwise exist' do
        for_each { |*, had_error| expect(had_error).to be_falsy }
      end
    end

    context 'when given --fish-completions' do
      it 'outputs all completions in fish "complete" format and exits with 0'
      it 'outputs the possible completions in fish "complete" format and exits with 0'
    end
  end
end
