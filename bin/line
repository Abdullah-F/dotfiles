#!/usr/bin/env ruby

class Line
  class Options < Struct.new(:show_help, :strip, :force, :chomp, :indexes, :errors, :instream, :outstream, :errstream, :help_screen)
    def initialize(attributes={})
      attributes.each { |attribute, value| __send__ "#{attribute}=", value }
      yield self if block_given?
    end

    alias show_help? show_help
    alias strip?     strip
    alias force?     force
    alias chomp?     chomp

    def help_screen
      super || (self.help_screen = '')
    end

    def indexes
      super || (self.indexes = [])
    end

    def errors
      super || (self.errors = {})
    end

    def instream
      super || $stdin
    end

    def outstream
      super || $stdout
    end

    def errstream
      super || $stderr
    end
  end

  class OptionParser
    def self.call(*args)
      new(*args).call
    end

    def initialize(arguments)
      @arguments = arguments
    end

    def call
      Options.new do |options|
        options.help_screen = help_screen
        invalid_args = []

        @arguments.each do |arg|
          case arg
          when '-h', '--help'  then options.show_help = true
          when '-s', '--strip' then options.strip     = true
          when '-f', '--force' then options.force     = true
          when '-c', '--chomp' then options.chomp     = true
          when '0'             then invalid_args << arg
          when /\A-?\d+\Z/     then options.indexes << arg.to_i
          else                      invalid_args << arg
          end
        end

        if invalid_args.size == 1
          options.errors[:line_numbers] = "#{invalid_args.first.inspect} is not a valid line number, offsets start from 1"
        elsif invalid_args.size > 1
          inspected_args = invalid_args.map(&:inspect)
          inspected_args[-1] = "and #{inspected_args[-1]}"
          options.errors[:line_numbers] = "#{inspected_args.join ', '} are not valid line numbers, offsets start from 1"
        elsif options.indexes.empty?
          options.errors[:line_numbers] = 'No line numbers provided'
        end
      end
    end

    def help_screen
      <<-HELP.gsub(/^      /, '')
      Usage: line [options] [numbers]

      Prints the lines at the given line numbers.
      The first line is line 1.

      options:
        -s, --strip   strip leading and tailing whitespace
        -f, --force   do not err when told to print a line number beyond the input
        -c, --chomp   no newlines between lines in the output
        -h, --help    this help screen

      examples:
        line 1 22  # prints lines 1 and 22
      HELP
    end
  end

  def self.call(*args)
    new(*args).call
  end

  attr_accessor :options

  def initialize(options)
    @options = options
  end

  def call
    if options.show_help?
      print_help
      return 0
    end

    if options.errors.any?
      print_errors
      return 1
    end

    print_lines

    if high_indexes.any? && !options.force?
      print_high_indexes
      return 1
    end

    return 0
  end

  private

  attr_accessor :max_index

  def print_help
    options.outstream.puts options.help_screen
  end

  def high_indexes
    @high_indexes ||= options.indexes.select { |index| index > max_index }
  end

  def print_errors
    options.errors.each do |type, message|
      options.errstream.puts message
    end
  end

  def print_high_indexes
    options.errstream.puts "Only saw #{max_index} lines of input, can't print lines: #{high_indexes.join ', '}"
  end

  def print_lines
    each_line do |line, positive_index, negative_index|
      next unless options.indexes.include?(positive_index) || options.indexes.include?(negative_index)
      line = line.strip if options.strip?
      if options.chomp?
        options.outstream.print line.chomp
      else
        options.outstream.puts line
      end
    end
  end

  def each_line
    each_line = options.instream.each_line.method(:next)
    QueueWithIndexes.new(buffer_size, &each_line).each do |line, positive_index, negative_index|
      positive_index += 1
      self.max_index = positive_index
      yield line, positive_index, negative_index
    end
  end

  def buffer_size
    min_index = options.indexes.min
    (min_index && min_index < 0) ? -min_index : 0
  end
end

class QueueWithIndexes
  def initialize(num_negatives=0, &input_generator)
    self.positive_index  = 0
    self.buffer          = []
    self.num_negatives   = num_negatives
    self.input_generator = input_generator
  end

  include Enumerable

  def each(&block)
    return to_enum :each unless block
    fill_the_buffer             until dry_generator? || full_buffer?
    flow_through_buffer(&block) until dry_generator?
    drain_the_buffer(&block)    until empty?
    self
  end

  def empty?
    fill_the_buffer
    buffer.empty?
  end

  private

  attr_accessor :dry_generator, :positive_index, :buffer, :num_negatives, :input_generator
  alias dry_generator? dry_generator

  def full_buffer?
    num_negatives <= buffer.size
  end

  def fill_the_buffer
    input = generate_input
    buffer << input unless dry_generator?
  end

  def flow_through_buffer(&block)
    flow_in = generate_input
    return if dry_generator?
    buffer << flow_in
    flow_out = buffer.shift
    block.call [flow_out, increment_index, nil]
  end

  def drain_the_buffer(&block)
    negative_index = -buffer.size
    value = buffer.shift
    block.call [value, increment_index, negative_index]
  end

  def generate_input
    input_generator.call
  rescue StopIteration
    self.dry_generator = true
  end

  def increment_index
    old_index = positive_index
    self.positive_index = positive_index + 1
    old_index
  end
end


if $0 !~ /rspec/
  exit Line.call Line::OptionParser.call ARGV
else
  describe Line::Options do
    let(:options) { described_class.new }

    it 'takes a hash of key/value pairs that it sets' do
      options = described_class.new(instream: 1, outstream: 2)
      options.instream.should == 1
      options.outstream.should == 2
    end

    it 'sets the instream to stdin by default', t:true do
      options.instream.should == $stdin
      options.instream = 123
      options.instream.should == 123
    end

    it 'sets the outstream to stdout by default' do
      options.outstream.should == $stdout
      options.outstream = 123
      options.outstream.should == 123
    end

    it 'sets the errstream to stderr by default' do
      options.errstream.should == $stderr
      options.errstream = 123
      options.errstream.should == 123
    end

    specify 'indexes defaults to an empty collection' do
      options.indexes.should == []
      options.indexes.should equal options.indexes
    end

    specify 'errors defaults to an empty hash' do
      options.errors.should == {}
      options.errors.should equal options.errors
    end

    specify 'the help screen defaults to an empty string' do
      options.help_screen.should == ''
      options.help_screen = 'help screen'
      options.help_screen.should == 'help screen'
    end
  end

  describe Line::OptionParser do
    def parse(args)
      Line::OptionParser.call(args)
    end

    specify 'it sets the help screen on the options' do
      parse([]).help_screen.tap do |help|
        help.should include '-h'
        help.should include '-s'
        help.should include '-f'
        help.should include '-c'
      end
    end

    specify '-h, --help sets the help screen' do
      parse([]).show_help?.should be_false
      parse(['-h']).show_help?.should be_true
      parse(['--help']).show_help?.should be_true
    end

    specify '-s, --strip sets strip' do
      parse([]).strip?.should be_false
      parse(['-s']).strip?.should be_true
      parse(['--strip']).strip?.should be_true
    end

    specify '-f, --force sets force' do
      parse([]).force?.should be_false
      parse(['-f']).force?.should be_true
      parse(['--force']).force?.should be_true
    end

    specify '-c, --chomp sets chomp' do
      parse([]).chomp?.should be_false
      parse(['-c']).chomp?.should be_true
      parse(['--chomp']).chomp?.should be_true
    end

    it 'aggregates integral non-flagged arguments in indexes' do
      parse(['-1', '1', '11']).indexes.should == [-1, 1, 11]
    end

    it 'has errors when no line numbers are provided' do
      parse(['1']).errors.should_not have_key :line_numbers
      parse([]).errors[:line_numbers].should == "No line numbers provided"
    end

    it 'has errors for 0, informing user that offset starts at 1' do
      parse(['1']).errors.should_not have_key :line_numbers
      parse(['0']).errors[:line_numbers].should == '"0" is not a valid line number, offsets start from 1'
      parse(['0', 'a', 'b']).errors[:line_numbers].should == '"0", "a", and "b" are not valid line numbers, offsets start from 1'
    end
  end

  describe Line do
    let(:_stderr)    { StringIO.new }
    let(:_stdout)    { StringIO.new }
    let(:_stdin)     { StringIO.new 100.times.map { |i| "line#{i.next}" }.join("\n") }
    let(:options)    { described_class::Options.new errstream: _stderr, outstream: _stdout, instream: _stdin }
    let(:stderr)     { exitstatus; _stderr.string }
    let(:stdout)     { exitstatus; _stdout.string }
    let(:exitstatus) { described_class.new(options).call }

    context 'when there are errors' do
      it 'prints the errors to the error stream and has an exit status of 1' do
        options.errors[:whatever] = "MAH ERRAH"
        stderr.should == "MAH ERRAH\n"
        exitstatus.should == 1
      end
    end

    context 'when there are no errors' do
      it 'prints nothing to stderr, and has an exit status of 0' do
        options.errors.should == {}
        stderr.should == ""
        exitstatus.should == 0
      end
    end

    specify 'when show_help is set, it displays the help screen and exits with 0' do
      options.help_screen = 'HELPME'
      options.show_help   = true
      stderr.should == ''
      stdout.should == "HELPME\n"
      exitstatus.should == 0
    end

    it 'prints the input lines at the specified indexes, starting at 1' do
      options.indexes << 1 << 3
      stdout.should == "line1\nline3\n"
    end

    it 'prints negative indexes from the end' do
      options.indexes << 98 << 100 << -2
      stdout.should == "line98\nline99\nline100\n"
    end

    context 'when there are not enough lines to print the given indexes' do
      it 'does not print an error and exits 0 when force is set' do
        options.force = true
        options.indexes << 101
        exitstatus.should == 0
        stderr.should be_empty
      end

      it 'prints an error and exits 1 when force is not set' do
        options.force = false
        options.indexes << 100 << 101 << 102
        exitstatus.should == 1
        stderr.should == "Only saw 100 lines of input, can't print lines: 101, 102\n"
      end
    end

    context 'when there is whitespace wrapping the lines' do
      before do
        _stdin.string = "  1  \n2"
        options.indexes << 1 << 2
      end

      it 'does not print the whitespace when strip is set' do
        options.strip = true
        stdout.should == "1\n2\n"
      end

      it 'prints the whitespace when strip is not set' do
        options.strip = false
        stdout.should == "  1  \n2\n"
      end
    end

    context 'when chomp is set' do
      it 'does not print newlines between the input lines' do
        _stdin.string = "  1  \n2"
        options.indexes << 1 << 2
        options.chomp = true
        stdout.should == "  1  2"
      end
    end
  end

  describe QueueWithIndexes do
    def generator
      values = ['a', 'b', 'c']
      lambda { values.shift || raise(StopIteration) }
    end

    specify '#each returns the queue' do
      queue = QueueWithIndexes.new(&generator)
      queue.each {}.should equal queue
    end

    specify '#each is lazy' do
      QueueWithIndexes.new(&generator).each.map { 1 }.should == [1, 1, 1]
    end

    it 'stops reading from the generator once the input_generator raises StopIteration' do
      values = %w[a b c]
      queue = QueueWithIndexes.new do
        if values.empty?
          values = %w[a b c]
          raise StopIteration
        end
        values.shift
      end
      queue.map(&:first).should == %w[a b c]
      queue.map(&:first).should == []
    end

    it 'takes a function that generates values' do
      a = ['a', 'b', 'c']
      QueueWithIndexes.new(&generator).to_a.should == [['a', 0, nil], ['b', 1, nil], ['c', 2, nil]]
    end

    it 'can be given a size, to determine how much to buffer in order to be able to tell you negative indexes' do
      QueueWithIndexes.new(2, &generator).to_a.should == [['a', 0, nil], ['b', 1, -2], ['c', 2, -1]]
    end

    example 'when the size given is greater than the number of values, every value has a negative index' do
      QueueWithIndexes.new(4, &generator).to_a.should == [['a', 0, -3], ['b', 1, -2], ['c', 2, -1]]
    end

    it 'is cool with each being called all multiple times and such' do
      queue = QueueWithIndexes.new(2, &generator)
      queue.take(1).should == [['a', 0, nil]]
      queue.take(1).should == [['b', 1, -2]]
      queue.take(1).should == [['c', 2, -1]]
      queue.take(1).should == []
    end

    describe 'empty?' do
      it 'is true when there are no elements in the input' do
        QueueWithIndexes.new { raise StopIteration }.should be_empty
      end

      it 'is false when there are elements in the input' do
        QueueWithIndexes.new(&generator).should_not be_empty
      end

      it 'becomes true when it runs out of inputs' do
        queue = QueueWithIndexes.new(2, &generator)
        queue.take 2
        queue.should_not be_empty
        queue.take 1
        queue.should be_empty
      end
    end
  end
end
