#!/usr/bin/env ruby

class Line
  module Matchers
    module Helpers
      def inspect_helper(has_parent, inspected)
        return inspected if has_parent
        "Matcher(#{inspected})"
      end
    end

    class Or
      include Helpers

      def initialize(matcher1, matcher2)
        @matcher1, @matcher2 = matcher1, matcher2
      end

      def matches?(*args)
        @matcher1.matches?(*args) || @matcher2.matches?(*args)
      end

      def inspect(has_parent=false)
        inspect_helper has_parent, "#{@matcher1.inspect true} || #{@matcher2.inspect true}"
      end
    end

    class And
      include Helpers

      def initialize(matcher1, matcher2)
        @matcher1, @matcher2 = matcher1, matcher2
      end

      def matches?(*args)
        @matcher1.matches?(*args) && @matcher2.matches?(*args)
      end

      def inspect(has_parent=false)
        inspect_helper has_parent, "#{@matcher1.inspect true} && #{@matcher2.inspect true}"
      end
    end

    class MatchEverything
      include Helpers

      def matches?(*)
        true
      end

      def inspect(has_parent=false)
        inspect_helper has_parent, "MatchEverything"
      end
    end

    class MatchNothing
      include Helpers

      def matches?(*)
        false
      end

      def inspect(has_parent=false)
        inspect_helper has_parent, "MatchNothing"
      end
    end

    class Index
      include Helpers

      attr_accessor :index

      def initialize(index)
        self.index = index
      end

      def matches?(line, positive_index, negative_index)
        positive_index == index || negative_index == index
      end

      def inspect(has_parent=false)
        inspect_helper has_parent, index.to_s
      end
    end

    class Range
      include Helpers

      attr_accessor :lower, :upper

      def initialize(lower, upper)
        self.lower, self.upper = lower, upper
      end

      def matches?(line, positive_index, negative_index)
        if negative_index && lower < 0 && upper < 0
          lower <= negative_index && negative_index <= upper
        elsif negative_index && lower < 0
          lower <= negative_index && positive_index <= upper
        elsif negative_index && upper < 0
          lower <= positive_index && negative_index <= upper
        elsif 0 < lower && 0 < upper
          lower <= positive_index && positive_index <= upper
        elsif 0 < lower
          lower <= positive_index
        elsif 0 < upper
          positive_index <= upper
        else
          false
        end
      end

      def inspect(has_parent=false)
        inspect_helper has_parent, "#{lower}..#{upper}"
      end
    end

    class Not
      include Helpers

      attr_accessor :matcher

      def initialize(matcher)
        self.matcher = matcher
      end

      def matches?(line, positive_index, negative_index)
        !matcher.matches?(line, positive_index, negative_index)
      end

      def inspect(has_parent=false)
        inspect_helper has_parent, "^(#{matcher.inspect true})"
      end
    end
  end

  class Options
    attr_accessor :show_help, :strip, :force, :chomp, :indexes, :errors, :line_matcher, :line_numbers
    attr_accessor :instream, :outstream, :errstream, :help_screen, :buffer_size, :debug

    def initialize(attributes={})
      update attributes
      yield self if block_given?
    end

    def update(attributes)
      attributes.each { |attribute, value| __send__ "#{attribute}=", value }
      self
    end

    alias line_numbers? line_numbers
    alias show_help?    show_help
    alias debug?        debug
    alias strip?        strip
    alias force?        force
    alias chomp?        chomp

    def help_screen
      @help_screen ||= ''
    end

    def indexes
      @indexes ||= []
    end

    def errors
      @errors ||= {}
    end

    def instream
      @instream ||= $stdin
    end

    def outstream
      @outstream ||= $stdout
    end

    def errstream
      @errstream ||= $stderr
    end

    def buffer_size
      @buffer_size ||= 0
    end
  end

  class OptionParser
    def self.call(*args)
      new(*args).call
    end

    def initialize(arguments)
      @arguments = arguments
    end

    def call
      Options.new do |options|
        options.help_screen  = help_screen
        options.line_matcher = nil
        invalid_args = []
        min_index    = 0

        @arguments.each do |arg|
          case arg
          when '-l', '--line-numbers' then options.line_numbers = true
          when '-h', '--help'         then options.show_help    = true
          when '-s', '--strip'        then options.strip        = true
          when '-f', '--force'        then options.force        = true
          when '-c', '--chomp'        then options.chomp        = true
          when '-d', '--debug'        then options.debug        = true
          when '0'                    then invalid_args << arg
          when /\A-?\d+..-?\d+/
            lower, upper = arg.split('..').map(&:to_i)
            options.indexes << lower << upper
            min_index = lower if lower < min_index
            min_index = upper if upper < min_index
            options.line_matcher ||= Matchers::MatchNothing.new
            options.line_matcher = Matchers::Or.new options.line_matcher, Matchers::Range.new(lower, upper)
          when /\A\^-?\d+\Z/
            index = arg[1..-1].to_i
            options.indexes << index
            min_index = index if index < min_index
            options.line_matcher ||= Matchers::MatchEverything.new
            options.line_matcher = Matchers::And.new options.line_matcher, Matchers::Not.new(Matchers::Index.new(index))
          when /\A-?\d+\Z/
            index = arg.to_i
            options.indexes << index
            min_index = index if index < min_index
            options.line_matcher ||= Matchers::MatchNothing.new
            options.line_matcher = Matchers::Or.new options.line_matcher, Matchers::Index.new(index)
          else
            invalid_args << arg
          end
        end

        if invalid_args.size == 1
          options.errors[:line_numbers] = "#{invalid_args.first.inspect} is not a valid line number, offsets start from 1"
        elsif invalid_args.size > 1
          inspected_args = invalid_args.map(&:inspect)
          inspected_args[-1] = "and #{inspected_args[-1]}"
          options.errors[:line_numbers] = "#{inspected_args.join ', '} are not valid line numbers, offsets start from 1"
        elsif options.line_matcher.nil? && options.line_numbers?
          options.line_matcher = Matchers::MatchEverything.new
        elsif options.line_matcher.nil?
          options.errors[:line_numbers] = 'No line numbers provided'
        end

        options.buffer_size = min_index.abs
      end
    end

    def help_screen
      <<-HELP.gsub(/^      /, '')
      Usage: line [options] matchers

      Prints the lines at the given line numbers.
      The first line is line 1.

      matchers:
        1      matches the first line
        -1     matches the last line
        ^1     matches lines other than 1
        1..10  matches lines 1 through 10 (ends can be negative)

      options:
        -l, --line-numbers  show line numbers in output
        -s, --strip         strip leading and tailing whitespace
        -f, --force         do not err when told to print a line number beyond the input
        -c, --chomp         no newlines between lines in the output
        -h, --help          this help screen

      examples:
        line 1 22    # prints lines 1 and 22
        line ^1 ^2   # prints all lines but the first two
        line -1      # prints the last line
        line ^-1     # prints all lines except the last one
        line 1..10   # prints lines 1 through 10
        line 5..-5   # prints all lines except the first and last four
      HELP
    end
  end

  def self.call(*args)
    new(*args).call
  end

  attr_accessor :options

  def initialize(options)
    @options = options
  end

  def call
    print_matcher if options.debug?

    if options.show_help?
      print_help
      return 0
    end

    if options.errors.any?
      print_errors
      return 1
    end

    print_lines

    if unseen_indexes.any? && !options.force?
      print_unseen_indexes
      return 1
    end

    return 0
  end

  private

  attr_accessor :max_index

  def unseen_indexes
    @unseen_indexes ||= options.indexes.dup
  end

  def print_help
    options.outstream.puts options.help_screen
  end

  def print_matcher
    options.errstream.puts options.line_matcher.inspect
  end

  def high_indexes
    @high_indexes ||= options.indexes.select { |index| index > max_index }
  end

  def print_errors
    options.errors.each do |type, message|
      options.errstream.puts message
    end
  end

  def print_unseen_indexes
    options.errstream.puts "Only saw #{max_index} lines of input, can't print lines: #{unseen_indexes.join ', '}"
  end

  def print_lines
    each_line do |line, positive_index, negative_index|
      unseen_indexes.delete positive_index
      unseen_indexes.delete negative_index
      next unless options.line_matcher.matches? line, positive_index, negative_index
      line = line.strip                   if options.strip?
      line = "#{positive_index}\t#{line}" if options.line_numbers?
      if options.chomp?
        options.outstream.print line.chomp
      else
        options.outstream.puts line
      end
    end
  end

  def each_line
    each_line = options.instream.each_line.method(:next)
    QueueWithIndexes.new(options.buffer_size, &each_line).each do |line, positive_index, negative_index|
      positive_index += 1
      self.max_index = positive_index
      debug_line line, positive_index, negative_index
      yield line, positive_index, negative_index
    end
  end

  def debug_line(line, positive_index, negative_index)
    return unless options.debug?
    options.errstream.puts "#{line.inspect}, #{positive_index.inspect}, #{negative_index.inspect}"
  end
end

class QueueWithIndexes
  def initialize(num_negatives=0, &input_generator)
    self.positive_index  = 0
    self.buffer          = []
    self.num_negatives   = num_negatives
    self.input_generator = input_generator
  end

  include Enumerable

  def each(&block)
    return to_enum :each unless block
    fill_the_buffer             until dry_generator? || full_buffer?
    flow_through_buffer(&block) until dry_generator?
    drain_the_buffer(&block)    until empty?
    self
  end

  def empty?
    fill_the_buffer
    buffer.empty?
  end

  private

  attr_accessor :dry_generator, :positive_index, :buffer, :num_negatives, :input_generator
  alias dry_generator? dry_generator

  def full_buffer?
    num_negatives <= buffer.size
  end

  def fill_the_buffer
    input = generate_input
    buffer << input unless dry_generator?
  end

  def flow_through_buffer(&block)
    flow_in = generate_input
    return if dry_generator?
    buffer << flow_in
    flow_out = buffer.shift
    block.call [flow_out, increment_index, nil]
  end

  def drain_the_buffer(&block)
    negative_index = -buffer.size
    value = buffer.shift
    block.call [value, increment_index, negative_index]
  end

  def generate_input
    input_generator.call
  rescue StopIteration
    self.dry_generator = true
  end

  def increment_index
    old_index = positive_index
    self.positive_index = positive_index + 1
    old_index
  end
end


if $0 !~ /rspec/
  exit Line.call Line::OptionParser.call ARGV
else

  class MatchIndexes
    def initialize(*indexes)
      @indexes = indexes
      @unmatched = []
      @matched   = []
    end

    attr_reader :indexes, :matched, :unmatched, :matcher

    def matches?(matcher)
      @matcher = matcher

      indexes.each do |index|
        indexes = [index, index]
        indexes = index if index.kind_of? Array
        if matcher.matches? '', *indexes
          matched << index
        else
          unmatched << index
        end
      end
      unmatched.empty?
    end

    def failure_message_for_should(*)
      "#{matcher.inspect} should have matched #{unmatched.inspect}"
    end

    def negative_failure_message(*)
      "#{matcher.inspect} shouldn't have matched #{matched.inspect}"
    end
  end

  def match_indexes(*indexes)
    MatchIndexes.new(*indexes)
  end
  alias match_index match_indexes

  def parse(args)
    Line::OptionParser.call(args)
  end

  def index_matcher(index)
    Line::Matchers::Index.new index
  end

  def index_matchers(*indexes)
    indexes.map { |index| index_matcher index }
  end

  def universal_matcher
    Line::Matchers::MatchEverything.new
  end

  describe Line::Options do
    let(:options) { described_class.new }

    it 'takes a hash of key/value pairs that it sets' do
      options = described_class.new(instream: 1, outstream: 2)
      options.instream.should == 1
      options.outstream.should == 2
    end

    it 'sets the instream to stdin by default', t:true do
      options.instream.should == $stdin
      options.instream = 123
      options.instream.should == 123
    end

    it 'sets the outstream to stdout by default' do
      options.outstream.should == $stdout
      options.outstream = 123
      options.outstream.should == 123
    end

    it 'sets the errstream to stderr by default' do
      options.errstream.should == $stderr
      options.errstream = 123
      options.errstream.should == 123
    end

    specify 'indexes defaults to an empty collection' do
      options.indexes.should == []
      options.indexes.should equal options.indexes
    end

    specify 'errors defaults to an empty hash' do
      options.errors.should == {}
      options.errors.should equal options.errors
    end

    specify 'the help screen defaults to an empty string' do
      options.help_screen.should == ''
      options.help_screen = 'help screen'
      options.help_screen.should == 'help screen'
    end

    specify 'buffer_size is 0 by default' do
      options.buffer_size.should == 0
      options.buffer_size = 123
      options.buffer_size.should == 123
    end
  end

  describe Line::OptionParser do
    specify 'it sets the help screen on the options' do
      parse([]).help_screen.tap do |help|
        help.should include '-h'
        help.should include '-s'
        help.should include '-f'
        help.should include '-c'
        help.should include '-l'
      end
    end

    specify '-h, --help sets show_help?' do
      parse([]).show_help?.should be_false
      parse(['-h']).show_help?.should be_true
      parse(['--help']).show_help?.should be_true
    end

    specify '-s, --strip sets strip' do
      parse([]).strip?.should be_false
      parse(['-s']).strip?.should be_true
      parse(['--strip']).strip?.should be_true
    end

    specify '-f, --force sets force' do
      parse([]).force?.should be_false
      parse(['-f']).force?.should be_true
      parse(['--force']).force?.should be_true
    end

    specify '-c, --chomp sets chomp' do
      parse([]).chomp?.should be_false
      parse(['-c']).chomp?.should be_true
      parse(['--chomp']).chomp?.should be_true
    end

    specify '-l, --line-numbers sets the line numbers option' do
      parse([]).line_numbers?.should be_false
      parse(['-l']).line_numbers?.should be_true
      parse(['--line-numbers']).line_numbers?.should be_true
    end

    specify '-l matches everything when no other matchers are provided' do
      parse(['-l']).line_matcher.should match_indexes *1..5
      parse(['-l', '1']).line_matcher.should match_index 1
      parse(['-l', '1']).line_matcher.should_not match_indexes 0, -1
    end

    specify '-d sets debug' do
      parse([]).debug?.should be_false
      parse(['-d']).debug?.should be_true
    end

    it 'treats integral non-flagged arguments as lines to match' do
      parse(['-1', '1', '11']).indexes.should == [-1, 1, 11]
      matcher = parse(['-1', '1', '11']).line_matcher
      matcher.should match_indexes -1, 1, 11
      matcher.should_not match_indexes -2, 0, 2, 10, 12
    end

    context 'when given ranges (e.g. 1..10)' do
      it 'has no errors' do
        parse(['1..10']).errors.should == {}
      end

      it 'puts the edges in the expected indexes' do
        parse(['5..8']).indexes.should == [5, 8]
        parse(['-8..-5']).indexes.should == [-8, -5]
      end

      it 'sets the buffer size' do
        parse(['-8..-5']).buffer_size.should == 8
        parse(['5..-5']).buffer_size.should  == 5
      end

      it 'creates a matcher that matches the range' do
        matcher = parse(['5..8']).line_matcher
        matcher.should     match_indexes [5, -1], [5, nil], [5, -100000]
        matcher.should     match_indexes [8, -1], [8, nil], [8, -100000]
        matcher.should     match_indexes [6, -1], [6, nil], [6, -100000]
        matcher.should_not match_indexes [4, -1], [9, nil]

        matcher = parse(['-8..-5']).line_matcher
        matcher.should match_indexes -8, -7, -6, -5
        matcher.should_not match_indexes -9, -4

        matcher = parse(['5..-5']).line_matcher
        matcher.should     match_indexes [5, -5], [6, nil], [6, -6]
        matcher.should_not match_indexes [4, nil], [4, -4], [4, -5], [5, -4]

        matcher = parse(['-5..5']).line_matcher
        matcher.should     match_indexes [5, -5], [5, -4], [4, -5], [5, nil], [4, nil]
        matcher.should_not match_indexes [5, -6], [6, nil], [6, -5], [4, nil], [4, -5]
      end
    end

    context 'when given negated numbers (e.g. ^1)' do
      it 'has no errors' do
        parse(['^1']).errors.should == {}
      end

      it 'puts them in the expected indexes' do
        parse(['^1']).indexes.should == [1]
      end

      it 'sets the buffer size' do
        parse(['^-3']).buffer_size.should == 3
      end

      it 'creates a matcher that matches their negation' do
        parse(['^2', '^4', '^-2']).line_matcher.should match_indexes 1, 3, 5, -1, -3
        parse(['^2', '^4', '^-2']).line_matcher.should_not match_indexes 2, 4, -2
      end
    end

    it 'sets the buffer_size to 0 if there are no negative indexes' do
      parse(['1']).buffer_size.should == 0
    end

    it 'sets the buffer_size such that it can access all the negative numbers' do
      parse(['1', '-1', '-3', '-2', '10']).buffer_size.should == 3
    end

    it 'has errors when no line numbers are provided and -l is not set' do
      parse(['1']).errors.should_not have_key :line_numbers
      parse(['-l']).errors.should_not have_key :line_numbers
      parse([]).errors[:line_numbers].should == "No line numbers provided"
    end

    it 'has errors for 0, informing user that offset starts at 1' do
      parse(['1']).errors.should_not have_key :line_numbers
      parse(['0']).errors[:line_numbers].should == '"0" is not a valid line number, offsets start from 1'
      parse(['0', 'a', 'b']).errors[:line_numbers].should == '"0", "a", and "b" are not valid line numbers, offsets start from 1'
    end
  end

  describe Line do
    let(:_stderr)    { StringIO.new }
    let(:_stdout)    { StringIO.new }
    let(:_stdin)     { StringIO.new 100.times.map { |i| "line#{i.next}" }.join("\n") }
    let(:args)       { ['-l'] }
    let(:options)    { parse(args).update errstream: _stderr, outstream: _stdout, instream: _stdin }
    let(:stderr)     { exitstatus; _stderr.string }
    let(:stdout)     { exitstatus; _stdout.string }
    let(:exitstatus) { described_class.new(options).call }

    context 'when there are errors' do
      it 'prints the errors to the error stream and has an exit status of 1' do
        options.errors = {whatever: "MAH ERRAH"}
        stderr.should == "MAH ERRAH\n"
        exitstatus.should == 1
      end
    end

    context 'when debug is set' do
      before { args << '-d' }
      it "prints the matcher's inspection to the errstream" do
        stderr.should include 'Matcher'
      end

      it "prints each line, the positive and negative indexes" do
        _stdin.string = "a\nb\nc\n"
        args << '-2'
        stderr.should include '"a\n", 1, nil'
        stderr.should include '"b\n", 2, -2'
        stderr.should include '"c\n", 3, -1'
      end
    end

    context 'when there are no errors' do
      it 'prints nothing to stderr, and has an exit status of 0' do
        options.errors = {}
        stderr.should == ""
        exitstatus.should == 0
      end
    end

    specify 'when show_help is set, it displays the help screen and exits with 0' do
      options.help_screen = 'HELPME'
      options.show_help   = true
      stderr.should == ''
      stdout.should == "HELPME\n"
      exitstatus.should == 0
    end

    it 'prints the input lines at the specified indexes, starting at 1' do
      args.replace %w[1 3]
      stdout.should == "line1\nline3\n"
    end

    it 'prints negative indexes from the end' do
      args.replace %w[98 100 -2]
      stdout.should == "line98\nline99\nline100\n"
    end

    context 'when there are not enough lines to print the given indexes' do
      it 'does not print an error and exits 0 when force is set' do
        args.replace %w[-f 101]
        exitstatus.should == 0
        stderr.should be_empty
      end

      it 'prints an error and exits 1 when force is not set' do
        args.replace %w[100 101 102 -100 -101]
        exitstatus.should == 1
        stderr.should == "Only saw 100 lines of input, can't print lines: 101, 102, -101\n"
      end
    end

    context 'when there is whitespace wrapping the lines' do
      before do
        _stdin.string = "  1  \n2"
        args.replace %w[1 2]
      end

      it 'does not print the whitespace when strip is set' do
        options.strip = true
        stdout.should == "1\n2\n"
      end

      it 'prints the whitespace when strip is not set' do
        options.strip = false
        stdout.should == "  1  \n2\n"
      end
    end

    context 'when chomp is set' do
      it 'does not print newlines between the input lines' do
        _stdin.string = "  1  \n2"
        args.replace %w[-c 1 2]
        stdout.should == "  1  2"
      end
    end

    context 'when line_numbers is set' do
      it 'prints the line numbers in front of the lines' do
        args.replace %w[1 2 -l]
        _stdin.string = "line1\nline2"
        stdout.should == "1\tline1\n2\tline2\n"
      end

      it 'does not interfere with other options' do
        args.replace %w[1 -s -l]
        _stdin.string = '  123  '
        stdout.should == "1\t123\n"
      end
    end
  end

  describe QueueWithIndexes do
    def generator
      values = ['a', 'b', 'c']
      lambda { values.shift || raise(StopIteration) }
    end

    specify '#each returns the queue' do
      queue = QueueWithIndexes.new(&generator)
      queue.each {}.should equal queue
    end

    specify '#each is lazy' do
      QueueWithIndexes.new(&generator).each.map { 1 }.should == [1, 1, 1]
    end

    it 'stops reading from the generator once the input_generator raises StopIteration' do
      values = %w[a b c]
      queue = QueueWithIndexes.new do
        if values.empty?
          values = %w[a b c]
          raise StopIteration
        end
        values.shift
      end
      queue.map(&:first).should == %w[a b c]
      queue.map(&:first).should == []
    end

    it 'takes a function that generates values' do
      a = ['a', 'b', 'c']
      QueueWithIndexes.new(&generator).to_a.should == [['a', 0, nil], ['b', 1, nil], ['c', 2, nil]]
    end

    it 'can be given a size, to determine how much to buffer in order to be able to tell you negative indexes' do
      QueueWithIndexes.new(2, &generator).to_a.should == [['a', 0, nil], ['b', 1, -2], ['c', 2, -1]]
    end

    example 'when the size given is greater than the number of values, every value has a negative index' do
      QueueWithIndexes.new(4, &generator).to_a.should == [['a', 0, -3], ['b', 1, -2], ['c', 2, -1]]
    end

    it 'is cool with each being called all multiple times and such' do
      queue = QueueWithIndexes.new(2, &generator)
      queue.take(1).should == [['a', 0, nil]]
      queue.take(1).should == [['b', 1, -2]]
      queue.take(1).should == [['c', 2, -1]]
      queue.take(1).should == []
    end

    describe 'empty?' do
      it 'is true when there are no elements in the input' do
        QueueWithIndexes.new { raise StopIteration }.should be_empty
      end

      it 'is false when there are elements in the input' do
        QueueWithIndexes.new(&generator).should_not be_empty
      end

      it 'becomes true when it runs out of inputs' do
        queue = QueueWithIndexes.new(2, &generator)
        queue.take 2
        queue.should_not be_empty
        queue.take 1
        queue.should be_empty
      end
    end
  end
end
